# KMP算法

 **KPM算法目的:**快速 从主串中匹配出与模式串相同的子串

## KMP算法的原理

### 需求

* 主串游标 i
* 模式串游标 j
* next数组:next[i]的值是当在于主串匹配时,模式串的第i个字符与主串不匹配时,**模式串游标**要等于的值

---
要想了解KMP算法，可以先了解*朴素匹配(暴力匹配)算法*。
KMP算法只会来回移动**游标 j** 而**游标 i**只会向前移动。
首先我们可以先看一下已经获得next数组的KMP算法

---

### KMP算法的关键：next数组的获取

#### 针对next数组当获取

```c
int* GetNextArray(const MyStr &T)
{
    int *next = new int[(T.Length + 1)];//next[0] isn't used.
    //next[1] = 0;
    //next[2] = 1;

    int i = 1, j = 0;

    while(i < T.Length)
    {
        if(j == 0 || T.str[i] == T.str[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }else
        {
            j = next[j];
        }
    }

    return next;
}
```

初始设置
设模式串为ABABCABAA,其长度为9;
next[1] = 0, i = 1, j = 0

当前i，j的值 | 要被匹配的串（最后一位由当前的i值来确定） | 前后缀最大匹配长度 | 给next赋值时的i，j的值 | next数组 |
------------ | ------------- | -------------- | -------------- |-------------- |
i = 1, j = 0| A | 0 | i = 2, j = 1 | next[2] = 1 |
i = 2, j = 1| AB | 0 | i = 3, j = 1 | next[3] = 1 |
i = 3, j = 1| ABA | 1 | i = 4, j = 2 | next[4] = 2 |
i = 4, j = 2| ABAB | 2 | i = 5, j = 3 | next[5] = 3 |
i = 5, j = 3| ABABC | 0 | i = 6, j = 1 | next[6] = 1 |
i = 6, j = 1| ABABCA | 1 | i = 7, j = 1 | next[7] = 1 |
i = 7, j = 1| ABABCAB | 2 | i = 8, j = 3 | next[8] = 3 |
i = 8, j = 3| ABABCABA | 3 | i = 9, j = 4 | next[9] = 4 |

>补充一下 在主串与模式串匹配时,匹配到ABABK时,K与C不匹配,next[5]=3 说明 ABAB前后缀最大匹配长度为2米,接下来的匹配j=3,而i不变

那么求next数组的算法与KMP匹配为什么又如此的相似呢?
我们取ABAB已经匹配完成,那么之后
i = 5, j = 3| ABABC |
-----|-----|
此时C与A不匹配,说明**C和AB(位置为3,4)组合形成的后缀串肯定找不到前缀串和它相匹配了!**
>此时如果C变成A,A与A匹配,那么就能得到前后缀匹配串ABA,那么next[6]=4

我们虽然确定了没有与ABC匹配的前缀串,但我们不能说就没有匹配前缀串了这里我不懂怎么说就你和A不匹配但是呢,next[3]前面的字符串有可能和你有匹配,而这个可能性是因为在确定next[5]时保证了j=3之前是有前后缀的匹配的,所以继续判断C(i=5)是否可能和(j=1)匹配,如果匹配的话,那么就有next[6] = next[3]+1 就是next[6] = ++j,如果继续不匹配,继续这个过程去找next[next[3]],一直到j = 0或者匹配

有点像数学归纳

顺着这个算法的逻辑来首先next[1] = 0和next[2] = 1是必定的,于是乎我们得到了一个可以有前后缀字符串匹配的集合
>{'A'}

如果继续匹配,B与{'A'}中的最后一个元素A不匹配,不能得到匹配前后串,j = 0,之后得到next[3]

继续匹配,发现A与{'A'}中的最后一个元素A匹配之后得到next[4],更新前后缀字符串匹配的集合
>{'AB'}

继续匹配,发现B与{'AB'}中的最后一个元素B匹配之后得到next[5],更新前后缀字符串匹配的集合
>{'ABA'}

继续匹配,发现C与{'ABA'}中的最后一个元素A不匹配,所以继续判断C(i=5)是否可能和(j=next[next[5]])匹配,一直重复到匹配或者j=0,之后得到next[6],如果匹配的话更新前后缀字符串匹配的集合
>{'XXX'}

如此往复
