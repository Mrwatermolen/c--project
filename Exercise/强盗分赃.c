#include <stdio.h>
/* Description
有天夜里5个强盗A、B、C、D、E抢到一大堆金币（金币个数不超过n个，n<=100000000），可是怎么也无法平均分成5份，
吵吵嚷嚷……

吵累了，只好先睡觉，准备第二天再分。

夜深了，一个强盗A偷偷爬起来，先拿了一个金币私下放自己口袋藏好，再将金币分为5等份，将自己的那一份再私藏好
就去睡觉了。

随着第二个强盗B也爬起来，也是私拿了一个金币再分5等份，也私藏起自己那份就睡觉去了。

后来的三个强盗C、D、E也都是这样办的。

问最初有多少个金币？（最初的金币个数有多种可能，请输出不超过n的所有可能，从小到大排列）

设金币总数n，由于5个强盗都是先藏一个后，发现余下的金币刚好均分5份，
所以设想在总数中加入4个新金币，则每个强盗占有的金币数不会改变（包括藏了的那一个），
从而每次分金币时这4个假想的金币会留存到后一层总数中，这使得每次分5份都是恰好的整数，
由此可见，n+4至少是5^5的整数倍，所以n的最小值为 5^5-4=3121。
其余可能的n值为 n = k*（5^5）-4，k为大于1的整数。
 */

int main()
{
    int n;
    scanf("%d", &n);
    if (n >= 3121)
    {
        printf("%d ", 3121);
        for (int k = 2; (k * 3125 - 4) <= n; ++k)
        {
            printf("%d ", (k * 3125 - 4));
        }
    }
    else
    {
        printf("impossible");
    }
    return 0;
}